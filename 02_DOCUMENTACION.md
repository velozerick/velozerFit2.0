Este documento presenta la documentación técnica completa del proyecto **VelozerFit**, una aplicación móvil de acondicionamiento físico desarrollada para la plataforma Android. En las siguientes secciones se detallan el objetivo de la aplicación, sus requerimientos funcionales y no funcionales, la arquitectura general del sistema, el diseño de la base de datos, la estructura de las principales pantallas (Activities), la forma en que se implementó el almacenamiento local con SQLite, la navegación mediante Intents, la lógica de las rutinas de ejercicio (cronómetro y control de series), las pruebas realizadas y las conclusiones del desarrollo.

## 1. Introducción

VelozerFit es una aplicación móvil de entrenamiento físico diseñada para ayudar a los usuarios a realizar rutinas de ejercicio de manera guiada y personalizada. La aplicación se enfoca en ejercicios organizados por grupos musculares (por ejemplo, hombros, bíceps, espalda, pecho, abdomen y piernas) para que el usuario pueda concentrarse en áreas específicas en sus entrenamientos. VelozerFit proporciona demostraciones en video de cada ejercicio mediante la integración con YouTube, así como una interfaz interactiva con cronómetro y control de series para facilitar el seguimiento de las rutinas. Al ser una aplicación nativa de Android, VelozerFit aprovecha un almacenamiento local (SQLite) para gestionar los datos de usuarios (registro e inicio de sesión) de forma segura y eficiente, permitiendo el uso de la app incluso sin conexión a internet para las funciones básicas (a excepción de la reproducción de videos). En resumen, VelozerFit busca ofrecer una experiencia completa de entrenamiento, combinando **contenido educativo** (videos de ejercicios) con **herramientas prácticas** (cronómetro, contador de series, registro de progreso básico) en una sola aplicación móvil.

## 2. Objetivo del Proyecto

El objetivo principal de VelozerFit es **proporcionar una plataforma móvil integral** que permita a los usuarios planificar y llevar a cabo rutinas de ejercicio personalizadas enfocadas en distintos grupos musculares, todo ello de forma **intuitiva y accesible**. A continuación se desglosan objetivos más específicos que derivan de este propósito general:

- **Educación en Ejercicios:** Brindar a los usuarios información y demostraciones visuales (videos) de al menos 5 ejercicios por cada grupo muscular, para asegurar que realicen los movimientos con la técnica correcta y variada.
- **Personalización:** Ofrecer una **bienvenida personalizada** y experiencia adaptada según el género del usuario (dirigiéndose al usuario como *“Bienvenido”*, *“Bienvenida”* o de forma neutra según corresponda).
- **Seguimiento de Rutinas:** Facilitar el seguimiento de una rutina de ejercicios mediante un cronómetro integrado y un contador de series seleccionable por el usuario. Esto permite que cada persona pueda ajustar la intensidad de su entrenamiento (por ejemplo, 3 series vs 5 series) y llevar el conteo fácilmente durante su sesión.
- **Accesibilidad y Comodidad:** Eliminar barreras de acceso a la información de entrenamiento, permitiendo que los usuarios consulten ejercicios y realicen rutinas **en cualquier momento y lugar** desde su smartphone, sin necesidad de equipo especializado más que el dispositivo móvil.
- **Almacenamiento Seguro de Datos:** Gestionar de forma segura los datos personales (credenciales de inicio de sesión y perfil básico) de cada usuario en un almacenamiento local confiable (base de datos SQLite), garantizando privacidad y disponibilidad de la información de inicio de sesión sin requerir conexión a internet.

En conjunto, estos objetivos apuntan a hacer de VelozerFit una herramienta útil tanto para principiantes que necesitan guía en sus ejercicios, como para usuarios intermedios que buscan organizar sus entrenamientos de manera estructurada.

## 3. Requerimientos Funcionales

Los requerimientos funcionales definen las **capacidades y comportamientos específicos** que la aplicación VelozerFit debe cumplir. A continuación se enumeran dichos requerimientos:

- **Registro de Usuarios:** La aplicación permitirá registrarse como nuevo usuario proporcionando un nombre de usuario, una dirección de email, una contraseña y la selección de su género (masculino, femenino u otro). Estos datos se almacenarán en la base de datos local para futuras autenticaciones.
- **Inicio de Sesión:** La aplicación deberá permitir que un usuario inicie sesión ingresando su nombre de usuario (o email registrado) y contraseña. El sistema validará las credenciales contra los datos almacenados en la base local SQLite. Solo usuarios autenticados podrán acceder a las funcionalidades principales de la app.
- **Mensaje de Bienvenida Personalizado:** Al iniciar sesión exitosamente, el usuario verá un mensaje de bienvenida personalizado en la pantalla principal, el cual se adaptará a su género. Por ejemplo, si el usuario registró género masculino aparecerá “**Bienvenido** [Nombre]”, si es femenino “**Bienvenida** [Nombre]”, y para género no binario o “otro” se puede usar un saludo neutro (por ejemplo, “**Bienvenid@** [Nombre]” o alguna formulación inclusiva).
- **Navegación por Grupos Musculares:** El usuario podrá navegar a una sección de ejercicios organizada por **grupos musculares**. La pantalla principal después de iniciar sesión mostrará los distintos grupos musculares disponibles (Hombros, Bíceps, Espalda, Pecho, Abdomen y Piernas). Al seleccionar uno de estos grupos, la app llevará al usuario a la lista de ejercicios correspondiente.
- **Lista de Ejercicios con Detalle:** Para cada grupo muscular seleccionado, la aplicación mostrará una lista de **5 ejercicios** específicos de ese grupo. De cada ejercicio se presentará: el **nombre del ejercicio**, una breve **descripción** sobre cómo realizarlo o sus beneficios, y un **ícono representativo** (imagen pequeña ilustrativa del ejercicio o del músculo trabajado). Esta lista permite al usuario familiarizarse con diferentes ejercicios para el grupo muscular elegido.
- **Reproducción de Video de Ejercicio:** Al hacer clic o tocar uno de los ejercicios listados, la aplicación debe mostrar o reproducir un **video demostrativo** del ejercicio. VelozerFit integrará videos alojados en **YouTube** para este propósito. Idealmente, la app lanzará un Intent implícito para abrir el enlace del video en la aplicación de YouTube instalada o en un reproductor web embebido, de forma que el usuario pueda ver la ejecución correcta del ejercicio seleccionado.
- **Selección de Número de Series:** Tras revisar los ejercicios de un grupo muscular, el usuario podrá indicar cuántas **series** (sets) desea realizar en su rutina para ese grupo. Al final de la pantalla de la lista de ejercicios (o en la pantalla de rutina), se mostrará una opción para seleccionar el número de series planificadas, por ejemplo mediante botones “+” y “–” para incrementar o disminuir el número, o mediante un selector numérico.
- **Inicio y Control de Rutina:** La aplicación proporcionará controles para manejar la rutina de ejercicio una vez iniciada. El usuario dispondrá de un botón **Iniciar Rutina** que comenzará el cronómetro y dará inicio a la cuenta de sus series, un botón de **Pausar** (que al pausarse cambiará a **Retomar** para reanudar) el cronómetro en caso de descansos, un botón **Siguiente Serie** para avanzar al siguiente conteo de serie una vez haya completado una serie de ejercicios, y eventualmente un botón **Finalizar Rutina** para dar por terminada la sesión antes de completar todas las series planificadas o al final de las mismas.
- **Cronómetro y Contador de Series:** Durante la rutina activa, la app mostrará un **cronómetro** en pantalla (mostrando el tiempo transcurrido, típicamente en formato mm:ss) y también indicará el **número de serie actual** que el usuario está ejecutando (p. ej., “Serie 2 de 5”). Cada vez que el usuario presione “Siguiente Serie”, el contador de series se incrementará hasta alcanzar el total seleccionado; el cronómetro podría reiniciarse para contar el tiempo de la nueva serie o continuar acumulando el tiempo total, según el comportamiento decidido en el diseño (ver sección de Lógica de Rutinas).
- **Persistencia de Datos de Usuario:** La información de registro del usuario (nombre, email, género, contraseña) debe almacenarse de forma persistente en la base de datos local (SQLite). La aplicación deberá poder recuperar estos datos para validar inicios de sesión y para mostrar la información personalizada (nombre, género para saludo). Los datos deben permanecer disponibles aunque la app se cierre y se vuelva a abrir (persistencia en almacenamiento interno del dispositivo).
- **Manejo de Errores Básicos:** (Implícito dentro de los demás requerimientos) La app debe manejar adecuadamente errores comunes, por ejemplo: no permitir registro con campos obligatorios vacíos, evitar duplicados de usuarios (misma email/nombre de usuario), mostrar mensajes de error si las credenciales de inicio de sesión son incorrectas, etc. Esto garantiza una experiencia de usuario adecuada cumpliendo los escenarios normales de uso.

## 4. Requerimientos No Funcionales

Además de las funciones que la aplicación debe cumplir, es importante especificar características de calidad, rendimiento y restricciones de entorno. Estos son los requerimientos no funcionales más relevantes para VelozerFit:

- **Usabilidad:** La interfaz de usuario debe ser intuitiva y fácil de navegar. Se busca que la experiencia sea sencilla incluso para personas con conocimientos técnicos limitados. Los botones y menús deben estar claramente identificados (por ejemplo, usando íconos reconocibles para *pausa*, *play*, *siguiente*, etc.), y el flujo de navegación (registro → inicio de sesión → selección de grupo → lista de ejercicios → rutina) debe resultar **natural y lógico** para el usuario promedio.
- **Rendimiento:** La aplicación debe ser **rápida y receptiva**. Las operaciones locales, como la validación de inicio de sesión contra SQLite, deben ocurrir en fracciones de segundo dada la poca carga de datos. La carga de listas de ejercicios y el inicio del cronómetro deben suceder sin demoras perceptibles. Un área que podría verse afectada en rendimiento es la reproducción de videos de YouTube, dependiendo de la velocidad de conexión a Internet del usuario, pero la app en sí debe manejar la llamada al video de forma eficiente (por ejemplo, usando Intents en lugar de cargar webs pesadas dentro de la app).
- **Compatibilidad:** VelozerFit debe ser compatible con una variedad de dispositivos Android. Se apunta a un soporte desde Android 5.0 (Lollipop) o superior, garantizando que funcione correctamente en distintas resoluciones de pantalla y tamaños (smartphones de diferentes pulgadas, e incluso tabletas si fuera posible, adaptando la UI con **layouts responsivos**). Se usará solo APIs estándar de Android para maximizar la compatibilidad.
- **Seguridad de Datos:** La aplicación manejará datos sensibles de usuarios (principalmente contraseñas). Por lo tanto, se debe asegurar que esta información esté protegida. A nivel local, se recomienda almacenar la contraseña en SQLite **cifrada o con hash** (por ejemplo, usando un algoritmo de hashing como SHA-256) en lugar de texto plano, para proteger contra accesos no autorizados al archivo de la base de datos. Además, la app no transmitirá estos datos externamente (toda la autenticación es local), reduciendo riesgos de intercepción.
- **Confiabilidad y Estabilidad:** VelozerFit debe funcionar de manera estable sin cierres inesperados (**crashes**). Se debe gestionar adecuadamente los casos excepcionales (por ejemplo, si falla la carga de un video externo, manejar la excepción sin que la app se cierre). La persistencia de datos en SQLite debe ser confiable: los datos de usuarios no deben corromperse incluso si la aplicación se cierra abruptamente.
- **Mantenibilidad:** El proyecto debe estar estructurado de forma que futuros desarrolladores puedan entender y modificar fácilmente el código. Esto implica seguir buenas prácticas en la organización del código Java/Kotlin (p. ej., separar la lógica de negocio de la lógica de interfaz en la medida de lo posible, quizá empleando patrones como MVC o MVVM), nombrar claramente variables y métodos, y comentar secciones complejas. También, documentar en este informe la arquitectura y decisiones técnicas contribuye a la mantenibilidad.
- **Escalabilidad:** Si bien la aplicación en su versión actual maneja un conjunto fijo de ejercicios y grupos musculares, se debe prever la posibilidad de ampliar el contenido (agregar más ejercicios, o nuevas categorías como tríceps, trapecio, etc.). La arquitectura debe permitir agregar nuevos ejercicios (posiblemente cargándolos en la base de datos o en recursos de la app) sin necesidad de reescribir grandes porciones del código existente.
- **Uso Sin Conexión (Offline):** Exceptuando la funcionalidad de reproducción de videos que requiere Internet, el resto de la app debería funcionar sin conexión. Esto significa que el inicio de sesión y registro (al ser locales) funcionarán offline, y las listas de ejercicios pueden estar pre-cargadas localmente (embebidas en la app o almacenadas en la base de datos). De este modo, un usuario podría consultar los nombres/descripciones de ejercicios y usar el cronómetro de rutina sin conexión. La experiencia completa (ver videos) obviamente sí necesitará conexión, pero la app debería informar al usuario si no hay conexión cuando intente ver un video, en lugar de fallar silenciosamente.

## 5. Arquitectura General de la Aplicación

En esta sección se describe la **arquitectura global** de VelozerFit, incluyendo el flujo de navegación principal (diagrama de flujo) y la forma en que los distintos componentes de la aplicación interactúan entre sí.

### 5.1 Diagrama de Flujo de Navegación

El flujo de navegación de VelozerFit se puede resumir en los siguientes pasos secuenciales por los que pasa el usuario, desde que abre la aplicación hasta que completa una rutina de ejercicios:

1. **Pantalla de Registro/Iniciar Sesión:** Al abrir la aplicación, si no hay ninguna sesión activa, el usuario es llevado a la pantalla de bienvenida donde puede elegir **Registrarse** (si es un usuario nuevo) o **Iniciar Sesión** (si ya tiene cuenta).
    - Si elige *Registrarse*, deberá ingresar nombre, email, contraseña y género, y luego la app crea su cuenta (inserta sus datos en la base de datos) y procede a la siguiente pantalla.
    - Si elige *Iniciar Sesión*, ingresará sus credenciales; la app valida contra la base de datos y, de ser correctas, procede a la siguiente pantalla.
2. **Pantalla de Bienvenida (Menú Principal):** Tras autenticarse, el usuario ve una pantalla principal con un **mensaje de bienvenida personalizado** (según su género) y la lista de **grupos musculares** disponibles. Esta pantalla sirve como menú de selección; el usuario escoge el grupo muscular en el que desea trabajar.
3. **Pantalla de Ejercicios por Grupo:** Al seleccionar un grupo muscular (p. ej., “Bíceps”), la aplicación muestra la lista de ejercicios correspondientes a ese grupo. Se listan 5 ejercicios con su nombre, descripción breve e ícono. El usuario puede desplazarse por la lista y leer sobre cada ejercicio. Si toca alguno, la aplicación procederá a mostrar el video de ese ejercicio.
4. **Visualización de Video de Ejercicio:** Cuando el usuario selecciona un ejercicio de la lista, VelozerFit lanza un componente de reproducción de video. Dependiendo de la implementación, puede ser:
    - Un **Intent implícito** que abre la aplicación de YouTube (o el navegador web) con la URL del video específico, saliendo momentáneamente de VelozerFit para ver el video y pudiendo regresar luego.
    - O bien un **visor embebido** dentro de la app (por ejemplo un WebView o una PlayerView de YouTube API) que muestra el video sin salir de VelozerFit.

    En ambos casos, el usuario puede ver la correcta ejecución del ejercicio. Una vez finalizado el video (o cuando el usuario decida volver), retorna a la lista de ejercicios para continuar.

5. **Selección de Series e Inicio de Rutina:** Después de que el usuario ha revisado los ejercicios del grupo muscular y está listo para ejercitar, indica cuántas series realizará en esta sesión para el grupo seleccionado. Esta selección se hace en la misma pantalla de ejercicios (por ejemplo en la parte inferior) o en una nueva pantalla dedicada a la rutina. El usuario ajusta el número de series deseadas (por ejemplo, 4 series) y luego presiona el botón **Iniciar Rutina**.
6. **Pantalla de Rutina Activa:** Al iniciar la rutina, la aplicación muestra la interfaz de entrenamiento en tiempo real. En esta pantalla se encuentra el **cronómetro** (inicialmente en 0:00), el **contador de series** indicando en qué serie se encuentra (p. ej., “Serie 1 de 4”), y los botones de control: *Pausar*, *Siguiente Serie*, *Finalizar*. El usuario realiza la primera serie de su ejercicio mientras el cronómetro corre; si necesita pausar, puede hacerlo (por descanso), y luego retomar. Al completar una serie, pulsa *Siguiente Serie*, con lo cual la aplicación incrementa el contador a serie 2 y (opcionalmente) reinicia el cronómetro para la siguiente serie. Esto se repite hasta completar todas las series programadas.
7. **Fin de Rutina:** Al terminar la última serie, el usuario puede pulsar *Finalizar Rutina* (o la app podría detectarlo automáticamente tras la última serie) para concluir. La aplicación entonces podría mostrar un mensaje de felicitación o resumen (por ejemplo “¡Rutina completada! Has realizado 4 series para Bíceps.”) y ofrecer la opción de volver al menú principal o salir. Si el usuario pulsa *Finalizar* antes de acabar todas las series, se considera que abortó la rutina y también regresa al menú principal, posiblemente con un mensaje de “Rutina finalizada anticipadamente”.
8. **Cierre de Sesión (Logout) [Opcional]:** En cualquier momento desde la pantalla principal, el usuario podría tener la opción de cerrar su sesión, lo que lo regresaría a la pantalla de inicio de sesión/registro. (Este no fue mencionado explícitamente en los requerimientos, pero es una funcionalidad típica; se menciona aquí por completitud de flujo).

Este flujo asegura que el usuario pase por todos los estados necesarios: autenticación, selección de contenido, aprendizaje del ejercicio, ejecución de la rutina y cierre. A nivel de implementación, cada uno de estos pasos corresponde generalmente a una **Activity** de Android .

### 5.2 Descripción de la Arquitectura

La arquitectura de VelozerFit sigue un modelo tradicional de aplicación móvil nativa sin una capa de servidor propia (aparte del uso de YouTube como proveedor de contenido de video). A continuación, se describen los principales componentes y cómo interactúan:

- **Activities (Actividades de Android):** La aplicación está dividida en varias pantallas, cada una implementada como una Activity independiente. Por ejemplo, hay una Activity de Registro/Inicio de Sesión, una Activity principal de Bienvenida/Grupos musculares, una Activity para la Lista de Ejercicios, y una Activity para la Rutina (cronómetro y series). Cada Activity se encarga de manejar la interfaz de usuario de esa pantalla y la lógica específica (por ejemplo, la Activity de Login valida credenciales, la Activity de Rutina maneja el cronómetro, etc.).
- **Intents:** La navegación entre pantallas se realiza mediante Intents (intenciones) explícitos. Cuando el usuario realiza una acción que requiere ir a otra pantalla, se lanza un Intent que especifica la siguiente Activity a abrir y se le puede adjuntar datos extras necesarios. Por ejemplo, tras iniciar sesión, un Intent lleva a la Activity principal y puede incluir en los “extras” el nombre y género del usuario para mostrar el saludo personalizado. Asimismo, para abrir un video de YouTube, se usa un Intent implícito con la acción de visualizar URI web, que Android redirige a la app apropiada (YouTube). (La navegación y Intents se detallan en la sección 10).
- **Base de Datos SQLite:** VelozerFit integra un componente de base de datos local SQLite para persistir datos. En términos de arquitectura, hay una clase administradora de la base de datos (generalmente una subclase de `SQLiteOpenHelper`) que se ocupa de crear las tablas requeridas y proveer métodos de acceso (inserción, consulta, actualización si fuese necesario). Las Activities invocan a esta capa de base de datos cuando requieren guardar o leer información. Por ejemplo, al registrar un usuario nuevo, la Activity de Registro llama a un método de la base de datos que inserta el usuario; al iniciar sesión, la Activity de Login consulta a la base si existe un usuario con esas credenciales. De esta manera, se aísla la lógica de almacenamiento en una capa separada, mejorando la organización del código (ver sección 9 para más detalles de SQLite).
- **Recursos de la Aplicación:** Los ejercicios y sus datos (nombre, descripción, ícono, enlace de video) están almacenados en los recursos de la app o en la base de datos local. Una decisión de diseño posible es almacenar esta información en la base de datos también, de modo que se pueda gestionar de forma similar a otros datos (ver sección 6, Estructura de BD). Alternativamente, podrían estar codificados en listas estáticas dentro de la app. En cualquier caso, la Activity de Lista de Ejercicios obtiene los ejercicios del grupo seleccionado desde esta capa de datos (sea base de datos o recursos estáticos) y los muestra en un listado (por ejemplo, usando un RecyclerView o ListView).
- **Integración con YouTube (Servicio externo):** VelozerFit no almacena localmente los videos de ejercicios (lo cual sería inviable por tamaño y actualización). En su lugar, almacena solo **referencias** (URLs o IDs de YouTube) para cada ejercicio. Cuando se requiere mostrar un video, la aplicación delega a YouTube. Esta interacción con un servicio externo se hace de forma simple mediante Intents implícitos, por lo que la arquitectura de la app se mantiene relativamente sencilla, sin necesidad de manejar streaming de video directamente.
- **Cronómetro y Control de Ejecución:** La funcionalidad de cronómetro se implementa usando componentes nativos de Android (por ejemplo, la clase `Chronometer` o mediante `Handler`/`Runnable` para actualizar un TextView cada segundo). Este componente reside dentro de la Activity de Rutina. La lógica de las series (incrementar contadores, habilitar/deshabilitar botones) también vive en dicha Activity. No se crea un servicio separado para el cronómetro ya que su alcance está limitado a cuando la Activity de Rutina está en foreground (visible); si la app creciera para soportar rutinas en background, podría considerarse un Service, pero no es necesario en la versión actual.

En términos de **patrones de diseño**, la aplicación sigue una separación simplificada de responsabilidades: las Activities actúan tanto de controlador de UI como de manejador de lógica para cosas sencillas (validaciones, interacciones con la base de datos), mientras que la clase de la base de datos encapsula las operaciones de persistencia. Dada la escala de la aplicación, esta arquitectura monolítica en el cliente es suficiente y manejable. Para proyectos más grandes, podría optarse por arquitectura MVC/MVP/MVVM, pero en VelozerFit no se consideró imprescindible formalizar uno de esos patrones debido a su alcance limitado.

## 6. Estructura de la Base de Datos

La aplicación utiliza **SQLite** como sistema de gestión de base de datos embebida para almacenar datos de la aplicación. A continuación se detalla la estructura diseñada para la base de datos de VelozerFit, incluyendo su **diagrama entidad-relación (ER)** y la descripción de cada tabla utilizada.

### 6.1 Diagrama ER

El diseño de la base de datos es relativamente simple, dado que la aplicación maneja pocos tipos de datos. Incluimos principalmente información de usuarios y de ejercicios. El siguiente diagrama ER describe las entidades y sus relaciones básicas:

```
Usuarios                      GruposMusculares            Ejercicios
---------                     ---------------            ----------
user_id (PK)                  group_id (PK)              exercise_id (PK)
nombre                        nombre                     nombre
email                                                    descripcion
password                                                 icono
genero                                                   video_url
                                                         grupo_id (FK → GruposMusculares.group_id)

```

(Diagrama ER textual: la tabla **Usuarios** tiene una clave primaria user_id y almacena nombre, email, password, género. La tabla **GruposMusculares** tiene clave primaria group_id y almacena el nombre del grupo (por ejemplo “Hombros”, “Bíceps”). La tabla **Ejercicios** tiene clave primaria exercise_id, y almacena el nombre del ejercicio, una descripción, el nombre de un recurso de icono (o ruta), la URL del video de YouTube, y una clave foránea grupo_id que referencia al ID del grupo muscular al que pertenece el ejercicio. La relación es de uno a muchos: un registro de **GruposMusculares** se relaciona con muchos **Ejercicios**, y cada ejercicio pertenece a un grupo muscular.)

### 6.2 Descripción de Tablas

A continuación se explican en detalle las tablas implementadas en la base de datos SQLite de la aplicación, junto con sus campos:

- **Tabla Usuarios:** Almacena la información de los usuarios registrados en la app. Sus campos son:
    - `user_id`: Clave primaria autoincremental (entero). Identifica de forma única a cada usuario registrado.
    - `nombre`: Texto. Nombre de usuario (o alias) elegido durante el registro. Se utiliza también para mostrar la bienvenida personalizada (“Bienvenido/a [nombre]”).
    - `email`: Texto. Correo electrónico del usuario. Debe ser único, ya que sirve como identificador alternativo para el inicio de sesión (la aplicación podría permitir iniciar sesión tanto con nombre de usuario como con email).
    - `password`: Texto. Contraseña del usuario, almacenada idealmente de forma segura (en la implementación básica podría estar en texto plano, pero se recomienda almacenarla en formato hash por seguridad).
    - `genero`: Texto. Género declarado del usuario, puede ser “M” (masculino), “F” (femenino) u “O” (otro/no binario). Esto se usa para determinar el saludo adecuado.

- *Nota:* Antes de insertar un nuevo usuario, la aplicación verifica que el email (o nombre de usuario) no exista ya en esta tabla, para evitar duplicados. Para la validación de inicio de sesión, se realiza una consulta buscando un registro cuyo email (o nombre) y password coincidan con lo ingresado.
- **Tabla GruposMusculares:** Contiene los distintos grupos musculares disponibles en la aplicación. Sus campos son:
    - `group_id`: Clave primaria (entero) asignado a cada grupo muscular.
    - `nombre`: Texto. Nombre del grupo muscular (por ejemplo: “Hombros”, “Bíceps”, “Espalda”, “Pecho”, “Abdomen”, “Piernas”).

    Esta tabla sirve para normalizar la relación con ejercicios. Al tener una tabla separada, es fácil ampliar o modificar los grupos musculares disponibles sin alterar directamente la tabla de ejercicios. En una implementación sencilla, esta tabla podría estar pre-poblada con los 6 grupos mencionados.

- **Tabla Ejercicios:** Almacena la información de cada ejercicio disponible en la app. Sus campos principales son:
    - `exercise_id`: Clave primaria (entero) para cada ejercicio.
    - `nombre`: Texto. Nombre del ejercicio (p. ej., “Elevaciones laterales”, “Curl de bíceps”).
    - `descripcion`: Texto. Descripción breve del ejercicio, explicando cómo realizarlo o qué músculo trabaja.
    - `icono`: Texto. Nombre de archivo o identificador del recurso de ícono que representa visualmente al ejercicio en la interfaz (puede ser el nombre de un archivo .png en los recursos de la app).
    - `video_url`: Texto. Enlace (URL) del video de YouTube que muestra la demostración del ejercicio. Puede ser una URL completa o solo un código de video dependiendo de cómo se implemente la reproducción.
    - `grupo_id`: Clave foránea (entero) que referencia a `GruposMusculares.group_id`, indicando a qué grupo muscular pertenece este ejercicio. Esta relación permite filtrar ejercicios por grupo (por ejemplo, “dame todos los ejercicios donde grupo_id = 2 (Bíceps)”).

    En la lógica de la app, cuando el usuario selecciona un grupo muscular en la pantalla principal, se ejecuta una consulta a la base de datos para obtener todos los ejercicios cuyo `grupo_id` corresponda a ese grupo. Los resultados de esa consulta se muestran en la lista de ejercicios.


Lla implementación actual, la base de datos se centra en la gestión de usuarios y ejercicios. No se está llevando un registro de rutinas realizadas ni histórico de entrenamientos (lo cual podría ser una futura mejora, añadiendo tablas como “Rutinas” o “Historial” que relacionen usuarios con ejercicios realizados y tiempos). Pero para el alcance definido, las tablas anteriores cubren los datos necesarios.

En la inicialización de la base de datos (generalmente en el método `onCreate` de la clase SQLiteOpenHelper), se ejecutan sentencias SQL `CREATE TABLE` para crear estas tablas. También podría haber inserciones iniciales (`INSERT`) para poblar la tabla de grupos musculares y ejercicios con los valores predeterminados de la aplicación.

## 7. Metodología de Desarrollo

Para el desarrollo de VelozerFit se optó por una **metodología incremental** (iterativa), combinando elementos de un ciclo de vida clásico en cascada con la flexibilidad de desarrollar y probar en múltiples fases. Este enfoque permitió construir la aplicación por módulos funcionales, verificando el cumplimiento de requerimientos a medida que se avanzaba y ajustando detalles según fuera necesario antes de proseguir con el siguiente módulo. A continuación, se describen las etapas seguidas durante el desarrollo:

- **1. Análisis de Requerimientos:** En primer lugar, se recopilaron y definieron claramente todos los requerimientos del proyecto (funcionales y no funcionales), tal como se listaron en las secciones 3 y 4. Se priorizaron las funciones esenciales (registro/login, visualización de ejercicios, cronómetro) asegurando comprender cómo debían funcionar desde la perspectiva del usuario. También se identificaron los recursos necesarios (videos de ejercicios, iconos, etc.).
- **2. Diseño (Arquitectura y UI):** Con los requerimientos claros, se diseñó la arquitectura general de la aplicación. Esto incluyó decidir las **Activities** que serían necesarias, cómo sería el flujo de navegación entre ellas (ver sección 5) y el diseño de la base de datos SQLite (sección 6). Paralelamente, se bosquejaron las interfaces de usuario para cada pantalla (wireframes y prototipos simples) definiendo la disposición de botones, listas y textos. Por ejemplo, se dibujó cómo luciría la pantalla de registro, la lista de ejercicios con sus iconos, y la pantalla del cronómetro con botones de control.
- **3. Implementación Inicial (Primer Incremento):** En la primera iteración de desarrollo se implementaron las funcionalidades básicas de **Registro e Inicio de Sesión** junto con la integración de la base de datos. Se creó la base de datos SQLite con sus tablas, y se programó la Activity de Registro para insertar nuevos usuarios, así como la Activity de Login para validar credenciales. En esta fase inicial el objetivo era tener lista la estructura fundamental para manejar usuarios, dado que es el punto de entrada a la app. Se realizaron pruebas unitarias básicas (por ejemplo, registrar un usuario y luego intentar iniciar sesión con esos datos).
- **4. Implementación de Listado de Ejercicios (Segundo Incremento):** En la siguiente iteración se abordó la parte de ejercicios. Se implementó la Activity principal con el menú de grupos musculares y la Activity que lista los ejercicios de un grupo. Se alimentó la base de datos con datos de ejemplo de ejercicios (5 por grupo) o se codificaron en la app. También se añadieron los recursos gráficos (íconos) correspondientes. En esta fase, al seleccionar un grupo muscular desde el menú principal, ya se podía navegar a una lista estática de ejercicios y ver sus detalles. Se probaron transiciones entre pantallas y que los datos correctos se mostraran para cada selección.
- **5. Integración de Videos (Tercer Incremento):** Una vez funcional la navegación y listado de ejercicios, se implementó la acción de ver los videos de los ejercicios. Se decidió usar Intents para lanzar los videos en YouTube, por ser más sencillo. Se probó que para cada ejercicio el enlace correcto abriera el video (en un dispositivo con conexión). Esta característica involucró pruebas en un dispositivo real o emulador con la app de YouTube instalada para verificar la comunicación entre aplicaciones.
- **6. Implementación de Rutina y Cronómetro (Cuarto Incremento):** En esta fase se desarrolló la Activity de Rutina, incluyendo el cronómetro y los controles de series. Fue una de las partes más interactivas: se añadió el elemento Cronómetro en la interfaz, se programó su inicio/pausa/reinicio, y se controló la lógica de avanzar de serie. Se hizo énfasis en manejar adecuadamente el estado de la interfaz: por ejemplo, deshabilitar el botón *Iniciar* una vez comenzada la rutina, cambiar *Pausar* por *Retomar* dinámicamente, etc. Esta etapa requirió pruebas intensivas, simulando el comportamiento del usuario (por ejemplo, pausar en medio de una serie, avanzar series rápidamente, finalizar antes de tiempo) para asegurar que el cronómetro y los contadores respondían correctamente en todos los casos.
- **7. Pruebas Integrales (Quinto Incremento):** Tras implementar todas las funcionalidades principales, se realizó una ronda de pruebas integrales cubriendo todos los casos de uso de la aplicación de principio a fin. Esto incluyó probar el flujo completo: registro -> login -> navegar por grupos -> ver ejercicios -> reproducir video -> seleccionar series -> ejecutar rutina -> finalizar. También pruebas de uso incorrecto o datos faltantes: intentar registrar con campos vacíos, login con contraseña incorrecta, flujo de rutina sin haber seleccionado series (en caso de que la UI lo permitiera), etc. Se corrigieron bugs descubiertos durante esta fase.
- **8. Refinamiento de UI y Detalles Finales:** Finalmente, se pulió la presentación visual (colores, alineaciones, textos) para asegurar un acabado profesional. Se agregaron mensajes emergentes (Toast o Dialogs) para confirmar acciones (como “Usuario registrado con éxito”, “Error: credenciales inválidas”, “Rutina completada”, etc.). También se revisó el código para limpiar logs de depuración y asegurar que no quedaran credenciales o datos sensibles expuestos.
- **9. Documentación:** Como culminación del proyecto, se elaboró la documentación técnica (este documento), describiendo todo el proceso, las especificaciones y consideraciones de desarrollo. Documentar fue importante para consolidar el conocimiento generado y facilitar mantenimiento futuro.

Esta metodología incremental permitió validar el proyecto por partes. Tras cada incremento, contábamos con una versión funcional de la app con nuevas características, lo que ayudó a detectar problemas temprano y a mantener un rumbo claro hacia el cumplimiento de todos los requerimientos. Además, dio flexibilidad para refinar requerimientos menores sobre la marcha (por ejemplo, ajustar la interfaz de rutina tras probarla inicialmente con usuarios de prueba).

## Uso de SQLite en el Proyecto

El uso de SQLite en VelozerFit es fundamental para la gestión de los datos de los usuarios (y opcionalmente de los ejercicios). A continuación, se detalla cómo se integró SQLite en la aplicación y cómo las diferentes operaciones de datos son realizadas:

- **Configuración de la Base de Datos:** Se creó una clase llamada, por ejemplo, `DatabaseHelper` que extiende de `SQLiteOpenHelper`. En esta clase se define:
    - Un **nombre de archivo** para la base de datos (p. ej., `velozerfit.db`).
    - La **versión** de la base de datos (un número entero que se incrementa si cambiamos la estructura de tablas en actualizaciones de la app).
    - En el método `onCreate(SQLiteDatabase db)` se ejecutan las sentencias SQL para crear las tablas necesarias (`CREATE TABLE Usuarios ...`, `CREATE TABLE GruposMusculares ...`, `CREATE TABLE Ejercicios ...` como se definió en la sección 6). Aquí también se podrían insertar datos iniciales, por ejemplo, popular la tabla de grupos musculares y ejercicios si decidimos almacenarlos en la base de datos en lugar de en recursos de la aplicación.
    - En el método `onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)` se maneja la migración de la base de datos en caso de cambios de versión (por ejemplo, podría eliminar tablas antiguas y crear las nuevas, o migrar datos). Para la primera versión de VelozerFit, este método puede estar vacío o eliminar y recrear tablas dado que no hay versiones previas.
- **Apertura y Cierre:** La `DatabaseHelper` se inicializa generalmente en la primera Activity que lo necesita (por ejemplo en LoginActivity). Internamente, `SQLiteOpenHelper` gestiona la apertura de la base (método `getWritableDatabase()` o `getReadableDatabase()`) creando el archivo físico en el almacenamiento interno del dispositivo la primera vez. El archivo suele ubicarse en el directorio interno de la app (ruta `/data/data/com.nombre.del.paquete/databases/velozerfit.db`). Esta base de datos es privada a la aplicación. Cuando la app se cierra, la base de datos permanece almacenada para la siguiente ejecución.
- **Operaciones CRUD (Create, Read, Update, Delete):** En VelozerFit se implementaron principalmente las operaciones de *Create* (inserción) y *Read* (lectura), ya que no hay funcionalidad para editar usuarios ni eliminar ejercicios en el alcance actual.
    - **Insert (Create):** Para registrar un usuario nuevo, la app construye un objeto `ContentValues` con las columnas `nombre, email, password, genero` y sus respectivos valores ingresados por el usuario. Luego llama a `db.insert("Usuarios", null, values)` utilizando la instancia de base de datos writable obtenida del helper. SQLite asigna automáticamente un `user_id` único. Antes de insertar, opcionalmente se pudo verificar que no exista ya ese email en la tabla (realizando una consulta SELECT). Para la tabla Ejercicios y GruposMusculares, las inserciones serían masivas al inicio (hardcodeadas) en `onCreate` o a través de scripts.
    - **Query (Read):** Para validar el inicio de sesión, se realiza una consulta SELECT sobre la tabla Usuarios con condiciones en email/nombre de usuario y password. Esto se hace usando el método `db.query(...)` o `db.rawQuery(...)` de SQLiteDatabase. Por ejemplo: `SELECT user_id, nombre, genero FROM Usuarios WHERE (email = ? OR nombre = ?) AND password = ?`. Si la consulta devuelve un resultado (Cursor con al menos un registro), significa que las credenciales son válidas. Del resultado se extrae el nombre y género (para el saludo) y quizá el user_id si se necesitara. Las consultas para obtener ejercicios se harían sobre la tabla Ejercicios filtrando por `grupo_id`. Estas operaciones de lectura se hicieron usando un `Cursor` para iterar sobre los resultados.
    - **Update:** No hubo un caso claro que requiriera actualizar datos en esta versión (quizá si permitiéramos cambiar la contraseña o editar perfil, usaríamos UPDATE en Usuarios).
    - **Delete:** Tampoco se implementó funcionalidad de borrado (por ejemplo, borrar cuenta) en este alcance. De ser necesario, se usaría `db.delete(...)` con la condición apropiada.
- **Manejo de Conexiones:** `DatabaseHelper` se usa típicamente como un singleton o se pasa entre Activities para reutilizar la conexión. Cada consulta abre la base si no está abierta. Es importante cerrar los Cursor después de las lecturas (`cursor.close()`) y eventualmente la base de datos al salir de la app (`db.close()`), aunque Android cierra automáticamente conexiones al terminar la app, es buena práctica administrarlo.
- **Uso de Room (posibilidad):** Cabe mencionar que Android ofrece una capa de abstracción más moderna llamada **Room** (parte de Android Jetpack) que simplifica el uso de SQLite y provee objetos DAO y entidades. En un proyecto profesional actual, podría considerarse usar Room en lugar de SQLiteOpenHelper puro, por sus ventajas (menos código boilerplate, verificaciones en tiempo de compilación de consultas SQL, etc.). Sin embargo, en VelozerFit se optó por la vía básica de SQLiteOpenHelper para mantener el proyecto simple y enfocado en el aprendizaje de los fundamentos.
- **Datos pre-cargados:** Como se comentó, de decidir almacenar también los ejercicios en SQLite, se aprovechó el método `onCreate` para insertar los registros de grupos musculares y ejercicios. Alternativamente, se pudo cargar estos datos la primera vez desde archivos JSON o CSV incluidos en los assets, pero dado el número pequeño de ejercicios se codificaron directamente en sentencias SQL o en el código de inicialización.

## Navegación entre Activities e Intents

La navegación dentro de VelozerFit se implementó utilizando **Intents**, el mecanismo estándar en Android para cambiar de pantalla y para invocar funcionalidades de otras aplicaciones. Hay dos tipos principales de intents usados en la aplicación: *intents explícitos* (para la navegación interna entre Activities de VelozerFit) e *intents implícitos* (para acciones externas, como abrir un video en YouTube).

- **Intents Explícitos (Navegación interna):** Son aquellos en los que se especifica directamente la clase de la Activity destino. En VelozerFit se emplearon en varios puntos:
    - Desde **RegisterActivity** o **LoginActivity** hacia **WelcomeActivity**: tras registrarse o iniciar sesión con éxito, se crea un Intent explícito indicando `WelcomeActivity.class` como destino. Antes de lanzarlo, se adjuntan datos del usuario en el Intent (por ejemplo, el nombre y género para el saludo) usando `intent.putExtra(key, value)`. Luego se invoca `startActivity(intent)` para abrir la pantalla de bienvenida. Además, se llama `finish()` en la Activity actual para que no quede en el historial de pantallas (de modo que el botón atrás no regrese al login una vez dentro de la app).
    - Desde **WelcomeActivity** hacia **ExerciseListActivity**: al seleccionar un grupo muscular, se lanza un Intent explícito hacia la pantalla de lista de ejercicios. Se pasa como extra un identificador o nombre de grupo para filtrar los datos que se mostrarán. Por ejemplo:

        ```
        Intent intent = new Intent(WelcomeActivity.this, ExerciseListActivity.class);
        intent.putExtra("grupo_id", idGrupoSeleccionado);
        startActivity(intent);

        ```


- En la ExerciseListActivity, en `onCreate`, se lee el extra con `getIntent().getIntExtra("grupo_id")` para saber qué ejercicios cargar.
- Desde **ExerciseListActivity** hacia **RoutineActivity**: de forma similar, al tocar *Iniciar Rutina*, se crea un Intent explícito a RoutineActivity incluyendo extras como el número de series seleccionado e información opcional (p. ej., grupo actual). RoutineActivity al iniciarse extrae esos valores para configurar su UI (muestra “Serie 1 de N”, etc.).
- Flujo inverso (volver atrás): la mayoría de los retornos se manejan simplemente con la tecla *Atrás* de Android o con `finish()`. Por ejemplo, al terminar RoutineActivity, se hace `finish()` para volver automáticamente a la lista de ejercicios (que quedó debajo en la pila). En algunos casos se usaron flags especiales: tras login/registro exitoso se usó `finish()` para remover esas pantallas del stack, y en caso de navegar de WelcomeActivity de nuevo a Login (logout) se podría usar `FLAG_ACTIVITY_CLEAR_TOP` para limpiar la pila hasta esa pantalla.
- **Intents Implícitos (Acciones externas):** Son aquellos en los que no se especifica un componente destino concreto, sino una acción a realizar, dejando que el sistema encuentre la aplicación apropiada. En VelozerFit se usaron para abrir los videos de ejercicios en YouTube:
    - Cuando el usuario selecciona un ejercicio, la app crea un Intent con la acción `ACTION_VIEW` y le asigna como datos la URI del video de YouTube. Por ejemplo:

```jsx
Uri videoUri = Uri.parse("https://www.youtube.com/watch?v=" + videoId);
Intent videoIntent = new Intent(Intent.ACTION_VIEW, videoUri);
startActivity(videoIntent);

```

- Aquí no mencionamos qué aplicación abrir; Android verá que es una URI web de YouTube y típicamente lanzará la aplicación de YouTube instalada, o de lo contrario un navegador web.
- De esta manera, VelozerFit aprovecha las apps externas. Mientras el usuario ve el video, nuestra app queda en segundo plano (ExerciseListActivity pausada). Al terminar o cerrar YouTube, el usuario vuelve automáticamente a VelozerFit en el punto donde estaba.
- Se agregó un pequeño control antes de `startActivity`: `if (videoIntent.resolveActivity(getPackageManager()) != null) { ... }` para asegurar que haya alguna app capaz de manejar el intent (si un usuario por algún motivo no tuviera navegador ni YouTube, cosa poco probable, se podría manejar ese caso).
- No se necesitó manejar retorno de datos desde YouTube (pues solo es ver un video), así que no se usó `startActivityForResult` ni similares en este contexto.
- **Paso de datos entre Activities:** Como se describió, se usaron los extras de Intents para transferir información necesaria de una pantalla a otra (ej. datos de usuario al welcome, id de grupo al listado, num. de series a la rutina). Esta es la forma más directa y recomendada de pasar datos en Android. En algunos casos se podrían usar alternativas (por ejemplo, SharedPreferences para persistir algo de estado global, o una clase singleton para mantener datos mientras la app está abierta), pero no fue necesario para nuestros casos. Mantener los datos en los Intents tiene la ventaja de que si la Activity destino se recrea, siempre volverá a recibir ese Intent con sus datos.
- **Comportamiento de la navegación (UX):** Se cuidó que la navegación fuera coherente:
    - Tras login, la pantalla de login se cierra para que el botón atrás no la muestre de nuevo; atrás desde welcome sale de la app.
    - Atrás desde la lista de ejercicios vuelve a welcome (menú).
    - Atrás desde rutina finaliza la rutina (como mencionado).

        También se procuró que acciones como registro o fin de rutina muestren feedback (mensajes) para que el usuario entienda lo que ocurrió y la app no parezca simplemente saltar de pantalla sin explicación.


En resumen, VelozerFit utiliza Intents explícitos para mover al usuario a través de las pantallas internas de la aplicación de manera controlada, y emplea Intents implícitos para delegar funciones especializadas (como reproducir videos) al sistema. Este enfoque sigue las convenciones de Android, resultando en un código más limpio y en una experiencia de usuario integrada con las capacidades del dispositivo (por ejemplo, aprovechar la app de YouTube que el usuario ya conoce para ver el contenido).

## Lógica de las Rutinas de Ejercicio

La **lógica de las rutinas** en VelozerFit abarca el funcionamiento interno de la pantalla de rutina: manejo del cronómetro, avance de series, pausa/reanudación y finalización. A continuación se explica cómo está implementada esta lógica paso a paso:

- **Inicialización de la Rutina:** Cuando RoutineActivity se inicia, lee del Intent el número total de series que el usuario seleccionó (por ejemplo, 4). Establece una variable `totalSeries` con ese valor y otra `serieActual` inicializada en 1. Se configura la vista para mostrar “Serie 1 de X” y el cronómetro en 00:00 antes de iniciar. El botón *Siguiente Serie* se mantiene deshabilitado inicialmente hasta que la rutina comience (para evitar pasarlo sin haber iniciado), y *Pausar* también puede estar inactivo hasta que haya algo que pausar.
- **Inicio del Cronómetro (Comenzar Rutina):** Al pulsar el botón *Iniciar Rutina*, se inicia el cronómetro. Si se usa un `Chronometer` de Android, esto equivale a hacer `chronometer.setBase(SystemClock.elapsedRealtime()); chronometer.start();`. El tiempo empieza a correr desde cero. Inmediatamente, el botón de *Iniciar* cambia su función a *Pausar* (podemos cambiar su texto/icono) para que el usuario pueda detener el tiempo si lo necesita. También en este momento habilitamos el botón *Siguiente Serie*, ya que ahora sí tiene sentido usarlo cuando termine la serie actual. El cronómetro seguirá contando en segundo plano y actualizando su display en la UI automáticamente.
- **Función Pausar/Retomar:** Si el usuario pulsa el botón *Pausar* durante la rutina:
    - Se detiene el cronómetro con `chronometer.stop()`. Esto congela el conteo en la pantalla.
    - Registramos el tiempo en el que quedó pausado. Con Chronometer, podemos calcularlo como `tiempoPausado = SystemClock.elapsedRealtime() - chronometer.getBase()`. Este valor representa los milisegundos transcurridos antes de pausar.
    - Cambiamos la etiqueta del botón *Pausar* a *Retomar* (indicando que al pulsarlo de nuevo continuará el cronómetro).
    - Mientras está en pausa, el usuario puede descansar. El cronómetro permanece congelado.
    - Al pulsar *Retomar*, calculamos la nueva base del cronómetro restando el tiempo ya transcurrido: `chronometer.setBase(SystemClock.elapsedRealtime() - tiempoPausado)`, y luego llamamos `chronometer.start()` otra vez. El cronómetro continúa desde el momento en que se pausó. El botón vuelve a decir *Pausar*.
    - Durante la pausa, el usuario aún podría pulsar *Siguiente Serie* si decide dar por terminada esa serie sin reanudar (no es lo usual, pero la opción existe). En tal caso, al avanzar de serie (como se explica abajo), reiniciamos de todos modos el cronómetro para la nueva serie.
- **Avanzar a la Siguiente Serie:** Cuando el usuario pulsa *Siguiente Serie* (indicando que terminó la serie actual):
    - Se obtiene la serie actual (por ejemplo, 1) y se compara con totalSeries. Si la serie actual < totalSeries, significa que todavía hay más series por hacer.
    - Se incrementa `serieActual` en 1 (ejemplo: pasa de 1 a 2).
    - Se actualiza el indicador de series en la UI a “Serie 2 de 4” (suponiendo el total era 4).
    - Se reinicia el cronómetro para contar desde cero la siguiente serie. Si el cronómetro estaba corriendo, primero se hace `chronometer.stop()`, luego `chronometer.setBase(SystemClock.elapsedRealtime())` y `chronometer.start()`. Si estaba pausado en el momento de pulsar siguiente, igualmente lo reiniciamos desde 0 para la nueva serie.
    - Aseguramos que el botón *Pausar/Retomar* esté en el estado inicial (por ejemplo, si estaba en Retomar porque estaba pausado, ahora que empieza nueva serie lo ponemos de nuevo como Pausar listo para usar).
    - Si por alguna razón esta era la última serie (serieActual se volvió igual a totalSeries después de incrementar), podríamos también deshabilitar *Siguiente Serie* ya que ya no habrá una “siguiente”. En la implementación, en lugar de deshabilitarlo, simplemente al pulsarlo en la última serie se manejará en el siguiente paso.
    - Caso especial: si el usuario pulsara *Siguiente Serie* estando ya en la última serie (lo cual no haría normalmente, pero supongamos totalSeries=4 y está en serieActual=4, aún podría pulsar el botón), incrementaría serieActual a 5, que sería > totalSeries. Podríamos detectar eso y tratarlo como finalización inmediata. Sin embargo, la interfaz está diseñada para que *Siguiente* no se use en la última serie, sino *Finalizar*.
- **Finalización de la Rutina:** Cuando el usuario pulsa *Finalizar Rutina* (o completa todas las series):
    - Se detiene el cronómetro si está corriendo (llamando otra vez a `chronometer.stop()`).
    - Dependiendo de la situación, se muestra un mensaje. Si completó todas las series planificadas, podría mostrarse un Toast de felicitación: “¡Rutina completada exitosamente!”. Si finalizó antes de tiempo, quizás un mensaje tipo “Rutina finalizada antes de completar todas las series”.
    - La app then cierra la RoutineActivity (`finish()`), lo que lleva de regreso a la pantalla previa (lista de ejercicios o menú principal).
    - Internamente, podríamos limpiar o resetear variables si la Activity fuera a permanecer en memoria, pero como se destruye no es necesario. Si quisiéramos guardar algún registro de la rutina (por ejemplo, cuántas series se hicieron efectivamente), este sería el momento de insertar esos datos en la base de datos o enviarlos a otro componente, pero esto está fuera del alcance actual.
- **Comportamiento de la Interfaz durante la rutina:** Durante la implementación se cuidó que:
    - El botón *Iniciar* solo se use al comienzo y luego quede reemplazado por Pausar/Retomar. Así se evita que el usuario intente “reiniciar” la rutina accidentalmente.
    - El botón *Siguiente Serie* no esté disponible hasta que haya iniciado la rutina (evitando pasar series sin haber comenzado).
    - Tras alcanzar la última serie, *Siguiente Serie* se podría deshabilitar para no exceder el conteo.
    - El botón *Finalizar* siempre esté visible y disponible para darle control total al usuario (en caso de fatiga o interrupción puede terminar la rutina en cualquier momento).
    - Si la Activity se pausa (por ejemplo, el usuario minimiza la app), al volver se retoma el estado del cronómetro correctamente. En esta implementación básica, no se manejó la persistencia del cronómetro al pausar la app; se asume que el usuario no saldrá de la app en medio de la rutina, pero en una versión más robusta se implementaría guardar el estado en `onPause` y restaurarlo en `onResume`.

## Pruebas Realizadas

La aplicación VelozerFit fue sometida a diversas **pruebas manuales** para verificar el correcto funcionamiento de todas sus características y asegurar que cumple con los requerimientos. A continuación se enumeran algunas de las pruebas funcionales realizadas y sus resultados esperados/observados:

- **Prueba de Registro de Usuario:** Se probó registrar usuarios nuevos con datos válidos (nombre, email y contraseña no vacíos). Resultado: el registro fue exitoso, mostrando un mensaje de confirmación y permitiendo iniciar sesión con esas credenciales. También se probaron casos de error: dejar campos obligatorios vacíos (la app no permitió avanzar, indicando el campo faltante) y usar un email ya registrado (la app rechazó el registro duplicado mostrando un mensaje de error “Usuario ya existe” o similar).
- **Prueba de Inicio de Sesión:** Se probó el inicio de sesión con credenciales correctas (de usuarios registrados) y con credenciales incorrectas. Resultado: con datos correctos, se accedió a la pantalla de bienvenida mostrando el saludo con el nombre del usuario; con datos erróneos (email no registrado o contraseña incorrecta), la app permaneció en la pantalla de login mostrando un mensaje “Credenciales inválidas, inténtalo de nuevo”. También se verificó el comportamiento al introducir un email en formato inválido (p. ej. sin @) y contraseña vacía: la app indicó los errores correspondientes sin intentar siquiera la autenticación hasta corregirlos.
- **Prueba de Navegación y Bienvenida:** Tras un login exitoso, se confirmó que la pantalla de bienvenida muestra el nombre del usuario y el saludo adecuado (“Bienvenido”/“Bienvenida” según género). Se probó con usuarios de distintos géneros para ver que el texto cambiara correctamente. También se verificó que desde la pantalla de bienvenida se puede seleccionar cualquier grupo muscular y la navegación ocurra sin problemas a la lista de ejercicios correspondiente. El botón de atrás en esta pantalla cierra la aplicación (comportamiento esperado para salir de la sesión).
- **Prueba de Lista de Ejercicios:** Para cada grupo muscular en el menú principal, se abrió la lista de ejercicios y se comprobó que efectivamente muestra 5 ejercicios relacionados. Se revisó que los datos (nombre y descripción) correspondieran al grupo seleccionado (por ejemplo, que en “Pecho” aparecieran ejercicios de pecho, etc.). Además, se verificó que la interfaz mostrara el ícono adecuado junto a cada ejercicio. Al hacer scroll, la lista se comportó fluidamente. No se encontraron incongruencias entre grupos y ejercicios, lo que confirmó que la consulta a la base de datos por `grupo_id` funciona correctamente.
- **Prueba de Reproducción de Video:** En cada pantalla de lista de ejercicios, se tocó cada ejercicio individual para asegurarse de que abriera el video correcto en YouTube. Se preparó el entorno con conexión a internet para esta prueba. Resultado: al tocar un ejercicio, la app lanzó la aplicación de YouTube (o un navegador en algún dispositivo de prueba sin YouTube instalado) y reprodujo el video asociado. Tras visualizar unos segundos, se usó el botón de back del dispositivo para volver a VelozerFit, comprobando que regresaba a la misma lista de ejercicios. Esta prueba confirmó que los enlaces de video (video_url) almacenados eran correctos y que los Intents implícitos estaban bien configurados. También se probó el caso de no tener conexión (desactivando WiFi/datos) e intentar abrir un video: la aplicación de YouTube mostró un mensaje de error de conexión, pero lo importante es que VelozerFit manejó la llamada sin colgarse; al volver, la app seguía operativa.
- **Prueba de Funcionalidad de Rutina:** Se realizaron múltiples pruebas en la pantalla de rutina para diferentes escenarios:
    - **Caso normal:** Seleccionar 3 series, iniciar rutina y completarlas todas. Se observó que el cronómetro comenzó en 0, el contador mostró “Serie 1 de 3”, y con cada pulsación de *Siguiente Serie* el contador avanzó correctamente a 2 de 3, luego 3 de 3, y después de la tercera serie se pulsó *Finalizar Rutina*. Resultado: cronómetro funcionó, conteo de series exacto, y al finalizar la rutina la app mostró un Toast de “Rutina completada” y volvió a la lista de ejercicios.
    - **Pausa y reanudación:** Durante una serie (por ejemplo la primera), se pulsó *Pausar* en el cronómetro. Este se detuvo en seco (se anotó mentalmente el tiempo, p. ej. 00:32). Luego se esperó unos segundos y se pulsó *Retomar*. El cronómetro continuó desde ~00:32 en adelante, indicando que había retenido el tiempo correctamente. Se repitió la pausa/reanudación varias veces en distintas series y el comportamiento siempre fue consistente.
    - **Salto de serie sin reanudar:** Se probó pausar el cronómetro y, mientras estaba pausado, pulsar *Siguiente Serie*. Resultado: el cronómetro se reinició para la siguiente serie (volviendo a 00:00) lo que tiene sentido, y el contador de series aumentó. Esto confirmó que incluso en escenarios no lineales la app maneja los estados apropiadamente.
    - **Finalización anticipada:** En medio de la segunda serie (de un total de 4 planificadas, por ejemplo), se pulsó *Finalizar Rutina*. Resultado: la rutina terminó de inmediato, la Activity se cerró y se volvió a la lista de ejercicios. Se observó el mensaje de finalización indicando que no se completaron todas las series (este mensaje fue genérico de rutina finalizada, pero es el comportamiento esperado).
    - **Vuelta atrás con botón del sistema:** Durante una rutina activa, en lugar de pulsar los botones de la app, se presionó el botón *Atrás* del teléfono. Resultado: la rutina se dio por terminada y se retornó al menú principal. En la implementación actual esto actúa como finalizar, lo cual coincidió con lo esperado.

    Todas estas pruebas confirmaron que la lógica de control de rutina (cronómetro y contador) funciona correctamente y es robusta ante distintas secuencias de acciones del usuario.

- **Prueba de Persistencia de Datos:** Se verificó que los datos de usuarios y ejercicios realmente persisten. Tras cerrar la aplicación completamente (forzar cierre) y volver a abrirla, se intentó iniciar sesión con un usuario previamente registrado. Resultado: la autenticación fue exitosa, demostrando que el usuario seguía existiendo en la base de datos local. Asimismo, se comprobó que la lista de ejercicios seguía poblada sin necesidad de internet, evidenciando que esa información está almacenada dentro de la app.
- **Pruebas de Interfaz y Compatibilidad:** Se ejecutó la aplicación en distintos dispositivos/emuladores (diferentes resoluciones de pantalla y versiones de Android). En todos los casos, la interfaz se adaptó correctamente (los elementos se reordenaron o escalaron de acuerdo al tamaño de pantalla usando los layouts estándar). En Android 8, 10 y 12 (versiones probadas), la app funcionó sin cambios en el comportamiento. Esto sugiere una buena compatibilidad hacia atrás gracias al uso de componentes estándar. También se probó la app tanto en orientación vertical (principal) como horizontal; si bien la app está pensada para vertical, en horizontal mantenía su funcionalidad aunque la distribución no estaba optimizada (esa podría ser una mejora futura).

Estas pruebas manuales aseguraron que cada parte de VelozerFit cumple con su función prevista y que, en conjunto, ofrecen una experiencia consistente. Cualquier incidencia encontrada durante las pruebas fue corregida antes de la versión final. No se detectaron errores críticos después de las rondas de prueba, por lo que se considera que la aplicación está lista para usarse en un entorno real.

En conclusión, el desarrollo de **VelozerFit** logró cumplir satisfactoriamente los objetivos propuestos. Se construyó una aplicación Android funcional que permite a los usuarios registrarse e iniciar sesión de forma segura, acceder a una variedad de ejercicios categorizados por grupo muscular y ejecutar rutinas de entrenamiento con asistencia de un cronómetro y contador de series. La combinación de contenido instructivo (videos de ejercicios) con herramientas interactivas (temporizador y control de series) proporciona una experiencia integral al usuario, facilitándole tanto el aprendizaje de nuevos ejercicios como la práctica estructurada de los mismos.

A nivel técnico, la app demostró ser **estable** y **eficiente**. La elección de SQLite para el almacenamiento local resultó adecuada, permitiendo la operación offline y un rendimiento muy rápido en las consultas. La arquitectura basada en Activities e Intents siguió las convenciones de Android, lo que hizo más sencilla la implementación y las pruebas, además de sentar bases claras para mantenimiento futuro. Asimismo, la documentación de cada componente (requerimientos, diseño, base de datos, etc.) asegura que el proyecto pueda ser entendido y extendido por otros desarrolladores si es necesario.

Entre las posibles **mejoras futuras** que podrían considerarse están: la incorporación de un módulo de seguimiento de progreso (por ejemplo, registrar cuándo el usuario completa una rutina y con qué resultados, para llevar un historial), la posibilidad de personalizar o crear rutinas combinando varios ejercicios, y una interfaz aún más pulida (quizá incluyendo imágenes de demostración en la lista de ejercicios o animaciones). También podría ampliarse el catálogo de ejercicios y grupos musculares según las necesidades de los usuarios.

VelozerFit cumple con ofrecer una herramienta móvil práctica y educativa para entrenamientos físicos. Tras un proceso de desarrollo iterativo con pruebas constantes, se alcanzó una aplicación robusta que proporciona a los usuarios una guía estructurada para ejercitarse, convirtiendo su dispositivo Android en un aliado para mejorar su condición física. El proyecto culmina con éxito, habiendo logrado integrar de manera armoniosa los distintos componentes (UI, lógica, base de datos y servicios externos) para brindar una solución tecnológica completa en el ámbito del fitness.
